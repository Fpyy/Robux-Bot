import discord
from discord.ext import commands
from discord.ui import Button, View, Select
from discord import app_commands, Embed
import requests
import json
from datetime import datetime
from dotenv import load_dotenv
import os
import asyncio

# Configura√ß√£o inicial
load_dotenv()
TOKEN = os.getenv("TOKEN")

intents = discord.Intents.default()
intents.message_content = True
intents.members = True

bot = commands.Bot(command_prefix="!", intents=intents)

# Vari√°veis globais
carrinhos_abertos = {}
CHAVE_PIX = "12423896603"
WEBHOOK_URL = "https://discord.com/api/webhooks/1353003630084624414/-mbkAxUmt-xmijNJYI6PP2prJy__R0kZl03djeXckn0LYPk8ebZmjbWD0MLa_8S-fv1A"

# Fun√ß√µes auxiliares
async def enviar_webhook(webhook_url, embed, cargos=None, canal_carrinho=None):
    data = {"embeds": [embed.to_dict()]}
    if cargos:
        data["content"] = cargos
    if canal_carrinho:
        data["embeds"][0]["fields"].append({
            "name": "üìå Canal do Carrinho:",
            "value": canal_carrinho.mention,
            "inline": False
        })
    
    try:
        response = requests.post(webhook_url, json=data)
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Erro ao enviar webhook: {e}")

async def purge_messages(channel, limit=10):
    def is_target(m):
        return m.author == bot.user or "carrinho" in m.content.lower()
    try:
        await channel.purge(limit=limit, check=is_target)
    except Exception as e:
        print(f"‚ùå Erro ao limpar mensagens: {e}")

def gerar_payload_pix(chave_pix, valor, nome_recebedor, cidade_recebedor):
    try:
        response = requests.get(
            "https://gerarqrcodepix.com.br/api/v1",
            params={
                "nome": nome_recebedor,
                "cidade": cidade_recebedor,
                "valor": valor,
                "saida": "br",
                "chave": chave_pix
            }
        )
        return response.json().get("brcode")
    except Exception as e:
        print(f"‚ùå Erro ao gerar PIX: {e}")
        return None

def get_roblox_user_id(username):
    try:
        response = requests.post(
            'https://users.roblox.com/v1/usernames/users',
            json={'usernames': [username], 'excludeBannedUsers': True},
            headers={'Content-Type': 'application/json'}
        )
        if response.status_code == 200:
            data = response.json()
            return data['data'][0]['id'] if data['data'] else None
    except Exception as e:
        print(f"‚ùå Erro ao buscar ID do Roblox: {e}")
    return None

def get_roblox_avatar_url(user_id):
    try:
        response = requests.get(
            f"https://thumbnails.roproxy.com/v1/users/avatar-headshot?userIds={user_id}&size=180x180&format=Png"
        )
        if response.status_code == 200:
            return response.json()["data"][0]["imageUrl"]
    except Exception as e:
        print(f"‚ùå Erro ao buscar avatar do Roblox: {e}")
    return None

async def create_private_channel(guild, user):
    try:
        categoria = guild.get_channel(1340128500228821032)
        if not categoria:
            await user.send("üî¥ **Erro:** Categoria n√£o encontrada!")
            return None

        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }

        for role in guild.roles:
            if role.permissions.administrator:
                overwrites[role] = discord.PermissionOverwrite(read_messages=True, send_messages=True)

        return await categoria.create_text_channel(
            name=f"üõí„Éªcarrinho-{user.name}",
            overwrites=overwrites
        )
    except Exception as e:
        print(f"‚ùå Erro ao criar canal privado: {e}")
        await user.send("üî¥ **Erro:** N√£o foi poss√≠vel criar seu carrinho!")
        return None

async def confirmar_cancelamento(interaction):
    try:
        embed = Embed(
            title="‚ùì Confirmar Cancelamento",
            description="**Tem certeza que deseja cancelar sua compra?**",
            color=discord.Color.orange()
        )
        embed.set_footer(text="Esta a√ß√£o n√£o pode ser desfeita!")
        
        class ConfirmacaoView(View):
            def __init__(self):
                super().__init__(timeout=None)
                self.add_item(Button(label="‚úÖ Sim", style=discord.ButtonStyle.danger))
                self.add_item(Button(label="‚ùå N√£o", style=discord.ButtonStyle.secondary))
            
            async def interaction_check(self, interaction):
                if interaction.data["custom_id"] == "‚úÖ Sim":
                    if interaction.user.id in carrinhos_abertos:
                        channel = carrinhos_abertos[interaction.user.id]
                        await channel.delete()
                        del carrinhos_abertos[interaction.user.id]
                    await interaction.response.send_message("üõë **Compra cancelada com sucesso!**", ephemeral=True)
                else:
                    await interaction.response.send_message("‚úÖ **Compra mantida!**", ephemeral=True)
                await interaction.message.delete()
                return False
        
        if not interaction.response.is_done():
            await interaction.response.send_message(embed=embed, view=ConfirmacaoView(), ephemeral=True)
        else:
            await interaction.followup.send(embed=embed, view=ConfirmacaoView(), ephemeral=True)
    except Exception as e:
        print(f"‚ùå Erro no cancelamento: {e}")

# Classes de View
class BaseView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(timeout=None, *args, **kwargs)

class PainelComprasView(BaseView):
    def __init__(self):
        super().__init__()
        
        select = Select(
            placeholder="üîç Selecione o m√©todo de compra",
            options=[
                discord.SelectOption(label="üí∞ Robux via Gamepass", value="gamepass", description="Compre Robux via Gamepass"),
                discord.SelectOption(label="üë• Robux via Grupo", value="grupo", description="Compre Robux via Grupo")
            ]
        )
        select.callback = self.select_callback
        self.add_item(select)
    
    async def select_callback(self, interaction):
        metodo = interaction.data["values"][0]
        await interaction.response.defer()
        
        if interaction.user.id in carrinhos_abertos:
            await interaction.followup.send(
                f"‚ö†Ô∏è **Voc√™ j√° tem um carrinho aberto em** {carrinhos_abertos[interaction.user.id].mention}",
                ephemeral=True
            )
            return

        channel = await create_private_channel(interaction.guild, interaction.user)
        if not channel:
            await interaction.followup.send("üî¥ **Erro:** N√£o foi poss√≠vel criar o carrinho!", ephemeral=True)
            return

        carrinhos_abertos[interaction.user.id] = channel
        
        embed = Embed(
            title="üõí Carrinho Criado!",
            description=f"Ol√° {interaction.user.mention}, seu carrinho foi criado com sucesso!\n\n"
                       f"üìå **Canal:** {channel.mention}\n"
                       f"‚è≥ **Tempo limite:** 5 minutos\n"
                       f"üõçÔ∏è **M√©todo:** {'Gamepass' if metodo == 'gamepass' else 'Grupo'}",
            color=discord.Color.green()
        )
        embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1128606053013176370.webp")
        
        await interaction.followup.send(embed=embed, ephemeral=True)
        
        embed_channel = Embed(
            title=f"üåü Bem-vindo ao seu Carrinho!",
            description=f"Ol√° {interaction.user.mention}, vamos come√ßar sua compra!\n\n"
                        f"üîπ **M√©todo selecionado:** {'Gamepass' if metodo == 'gamepass' else 'Grupo'}\n"
                        f"üîπ **Aten√ß√£o:** Voc√™ tem 5 minutos para cada a√ß√£o\n"
                        f"üîπ **D√∫vidas?** Aguarde um atendente",
            color=discord.Color.blue()
        )
        await channel.send(embed=embed_channel)
        await send_painel_atendimento(channel, metodo)

class PainelAtendimentoView(BaseView):
    def __init__(self, metodo_compra):
        super().__init__()
        self.metodo_compra = metodo_compra
        
        if metodo_compra == "gamepass":
            self.add_item(Button(emoji="üí∏", label="Com Taxa (R$45/1k)", style=discord.ButtonStyle.red, custom_id="com_taxa"))
            self.add_item(Button(emoji="üí∞", label="Sem Taxa (R$35/1k)", style=discord.ButtonStyle.green, custom_id="sem_taxa"))
        elif metodo_compra == "grupo":
            self.add_item(Button(emoji="üí∏", label="Com Taxa (R$45/1k)", style=discord.ButtonStyle.red, custom_id="com_taxa"))
        
        self.add_item(Button(emoji="‚ùå", label="Cancelar Compra", style=discord.ButtonStyle.danger, custom_id="cancelar", row=1))

    async def interaction_check(self, interaction):
        try:
            if interaction.data["custom_id"] == "com_taxa":
                await interaction.response.defer()
                await send_carrinho_embed(interaction, 45.00)
            elif interaction.data["custom_id"] == "sem_taxa":
                await interaction.response.defer()
                await send_carrinho_embed(interaction, 35.00)
            elif interaction.data["custom_id"] == "cancelar":
                await interaction.response.defer()
                await confirmar_cancelamento(interaction)
        except Exception as e:
            print(f"‚ùå Erro na intera√ß√£o: {e}")

class CarrinhoView(BaseView):
    def __init__(self, preco_por_1000, original_message=None):
        super().__init__()
        self.preco_por_1000 = preco_por_1000
        self.quantidade = None
        self.original_message = original_message
        
        self.add_item(Button(emoji="‚û°Ô∏è", label="Prosseguir", style=discord.ButtonStyle.primary, custom_id="prosseguir"))
        self.add_item(Button(emoji="üîô", label="Voltar", style=discord.ButtonStyle.secondary, custom_id="voltar"))
        self.add_item(Button(emoji="‚ùå", label="Cancelar", style=discord.ButtonStyle.danger, custom_id="cancelar", row=1))

    async def interaction_check(self, interaction):
        try:
            if interaction.data["custom_id"] == "prosseguir":
                await interaction.response.defer()
                await self.prosseguir_compra(interaction)
            elif interaction.data["custom_id"] == "voltar":
                await interaction.response.defer()
                await purge_messages(interaction.channel)
                await send_painel_atendimento(interaction.channel, "gamepass")
            elif interaction.data["custom_id"] == "cancelar":
                await interaction.response.defer()
                await confirmar_cancelamento(interaction)
        except Exception as e:
            print(f"‚ùå Erro no carrinho: {e}")

    async def prosseguir_compra(self, interaction):
        embed = Embed(
            title="üîç Confirma√ß√£o de Usu√°rio",
            description="Por favor, **digite seu nome de usu√°rio do Roblox** no chat:",
            color=discord.Color.blue()
        )
        embed.set_footer(text="Voc√™ tem 1 minuto para responder")
        await interaction.followup.send(embed=embed)
        
        def check(m):
            return m.author == interaction.user and m.channel == interaction.channel
        
        try:
            msg = await bot.wait_for("message", timeout=60.0, check=check)
            username = msg.content
            user_id = get_roblox_user_id(username)
            
            if not user_id:
                embed = Embed(
                    title="‚ùå Usu√°rio n√£o encontrado",
                    description="N√£o foi poss√≠vel encontrar esse usu√°rio no Roblox.\nPor favor, digite novamente:",
                    color=discord.Color.red()
                )
                await interaction.followup.send(embed=embed)
                return
            
            avatar_url = get_roblox_avatar_url(user_id)
            if not avatar_url:
                avatar_url = "https://cdn.discordapp.com/emojis/1128606053013176370.webp"
            
            embed = Embed(
                title="‚úÖ Usu√°rio Encontrado!",
                description=f"Este √© o usu√°rio **{username}** do Roblox?\n\n"
                            "Confirme abaixo para prosseguir com o pagamento:",
                color=discord.Color.green()
            )
            embed.set_thumbnail(url=avatar_url)
            embed.set_image(url=avatar_url)
            
            view = ConfirmarUsuarioView(interaction, username, self.quantidade, self.preco_por_1000)
            await interaction.followup.send(embed=embed, view=view)
            await msg.delete()
            
        except asyncio.TimeoutError:
            embed = Embed(
                title="‚è∞ Tempo Esgotado",
                description="Voc√™ demorou muito para responder.\nPor favor, inicie novamente o processo.",
                color=discord.Color.red()
            )
            await interaction.followup.send(embed=embed)

class ConfirmarUsuarioView(BaseView):
    def __init__(self, interaction, username, quantidade, preco_por_1000):
        super().__init__()
        self.interaction = interaction
        self.username = username
        self.quantidade = quantidade
        self.preco_por_1000 = preco_por_1000
        
        self.add_item(Button(emoji="‚úÖ", label="Sim, Continuar", style=discord.ButtonStyle.success, custom_id="sim"))
        self.add_item(Button(emoji="‚ùå", label="N√£o, Corrigir", style=discord.ButtonStyle.danger, custom_id="nao"))

    async def interaction_check(self, interaction):
        try:
            if interaction.data["custom_id"] == "sim":
                await interaction.response.defer()
                await self.processar_pagamento(interaction)
            elif interaction.data["custom_id"] == "nao":
                await interaction.response.defer()
                embed = Embed(
                    title="üîç Digite Novamente",
                    description="Por favor, **digite seu nome de usu√°rio do Roblox** novamente:",
                    color=discord.Color.blue()
                )
                await interaction.followup.send(embed=embed)
        except Exception as e:
            print(f"‚ùå Erro na confirma√ß√£o: {e}")

    async def processar_pagamento(self, interaction):
        valor_total = (self.quantidade / 1000) * self.preco_por_1000
        payload_pix = gerar_payload_pix(CHAVE_PIX, f"{valor_total:.2f}", "Bernardo", "Rio de Janeiro")
        
        if not payload_pix:
            embed = Embed(
                title="‚ùå Erro no Pagamento",
                description="N√£o foi poss√≠vel gerar o c√≥digo PIX.\nPor favor, tente novamente mais tarde.",
                color=discord.Color.red()
            )
            await interaction.followup.send(embed=embed)
            return
        
        embed = Embed(
            title="üí≥ PAGAMENTO VIA PIX",
            description=f"**Valor total:** R$ {valor_total:.2f}\n\n"
                       f"üìå **Instru√ß√µes:**\n"
                       f"1. Abra seu app de pagamentos\n"
                       f"2. Escolha pagar via PIX\n"
                       f"3. Escolha 'PIX Copia e Cola'\n"
                       f"4. Cole o c√≥digo abaixo\n\n"
                       f"‚è≥ **Tempo limite:** 30 minutos",
            color=discord.Color.green()
        )
        embed.add_field(name="üìã C√≥digo PIX:", value=f"```{payload_pix}```", inline=False)
        embed.set_footer(text="Ap√≥s o pagamento, aguarde a confirma√ß√£o!")
        
        view = PagamentoView(self.interaction, self.username, self.quantidade, payload_pix)
        await interaction.followup.send(embed=embed, view=view)

class PagamentoView(BaseView):
    def __init__(self, interaction, username, quantidade, payload_pix):
        super().__init__()
        self.interaction = interaction
        self.username = username
        self.quantidade = quantidade
        self.payload_pix = payload_pix
        
        self.add_item(Button(emoji="üìã", label="Copiar PIX", style=discord.ButtonStyle.blurple, custom_id="copiar"))
        self.add_item(Button(emoji="‚ùå", label="Cancelar", style=discord.ButtonStyle.danger, custom_id="cancelar"))
        self.add_item(Button(emoji="‚úÖ", label="Marcar como Entregue", style=discord.ButtonStyle.success, custom_id="entregue", row=1))

    async def interaction_check(self, interaction):
        try:
            if interaction.data["custom_id"] == "copiar":
                await interaction.response.send_message(f"üìã **C√≥digo PIX copiado!**\n```{self.payload_pix}```", ephemeral=True)
            elif interaction.data["custom_id"] == "cancelar":
                await interaction.response.defer()
                await confirmar_cancelamento(interaction)
            elif interaction.data["custom_id"] == "entregue":
                await interaction.response.defer()
                await self.marcar_entregue(interaction)
        except Exception as e:
            print(f"‚ùå Erro no pagamento: {e}")

    async def marcar_entregue(self, interaction):
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("üî¥ **Erro:** Apenas administradores podem marcar como entregue!", ephemeral=True)
            return
        
        comprador = interaction.guild.get_member(self.interaction.user.id)
        if comprador:
            embed = Embed(
                title="‚úÖ COMPRA FINALIZADA!",
                description=f"{comprador.mention}, sua compra foi conclu√≠da com sucesso!\n\n"
                            f"üìå **Detalhes:**\n"
                            f"üîπ **Usu√°rio Roblox:** {self.username}\n"
                            f"üîπ **Quantidade:** {self.quantidade} Robux\n"
                            f"üîπ **Valor Total:** R$ {(self.quantidade/1000)*self.preco_por_1000:.2f}\n"
                            f"üîπ **Entregue por:** {interaction.user.mention}",
                color=discord.Color.green()
            )
            embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1128606053013176370.webp")
            
            try:
                await comprador.send(embed=embed)
            except:
                pass
        
        # Enviar para webhook
        embed_webhook = Embed(
            title="üì¶ COMPRA CONCLU√çDA",
            description=f"Uma compra foi finalizada por {interaction.user.mention}",
            color=discord.Color.gold()
        )
        embed_webhook.add_field(name="üë§ Comprador", value=comprador.mention, inline=True)
        embed_webhook.add_field(name="üéÆ Roblox", value=self.username, inline=True)
        embed_webhook.add_field(name="üí∞ Valor", value=f"R$ {(self.quantidade/1000)*self.preco_por_1000:.2f}", inline=True)
        embed_webhook.add_field(name="üõí M√©todo", value="Gamepass" if self.preco_por_1000 in [35, 45] else "Grupo", inline=True)
        embed_webhook.add_field(name="üõçÔ∏è Quantidade", value=f"{self.quantidade} Robux", inline=True)
        embed_webhook.add_field(name="üîÑ Entregue por", value=interaction.user.mention, inline=True)
        
        await enviar_webhook(WEBHOOK_URL, embed_webhook, cargos="@everyone")
        
        # Fechar carrinho
        if self.interaction.user.id in carrinhos_abertos:
            try:
                await carrinhos_abertos[self.interaction.user.id].delete()
            except:
                pass
            del carrinhos_abertos[self.interaction.user.id]
        
        await interaction.followup.send("‚úÖ **Compra marcada como entregue com sucesso!**", ephemeral=True)

# Fun√ß√µes principais
async def send_painel_atendimento(channel, metodo_compra):
    gamepass_msg = "üí∞ **Gamepass sem taxa** - R$35/1k\nüí∏ **Gamepass com taxa** - R$45/1k"
    grupo_msg = "üí∏ **Apenas com taxa** - R$45/1k"
    
    embed = Embed(
        title=f"üõçÔ∏è M√©todo de Compra - {'Gamepass' if metodo_compra == 'gamepass' else 'Grupo'}",
        description=f"Selecione como deseja comprar seus Robux:\n\n{gamepass_msg if metodo_compra == 'gamepass' else grupo_msg}",
        color=discord.Color.blue()
    )
    embed.set_footer(text="Clique nos bot√µes abaixo para selecionar")
    await channel.send(embed=embed, view=PainelAtendimentoView(metodo_compra))

async def send_carrinho_embed(interaction, preco_por_1000):
    embed = Embed(
        title="üõí Seu Carrinho de Compras",
        description="Informe **quantos Robux** voc√™ deseja comprar:\n\n"
                   f"üíµ **Pre√ßo por 1.000 Robux:** R$ {preco_por_1000:.2f}",
        color=discord.Color.blue()
    )
    embed.add_field(name="üî¢ Quantidade", value="Digite no chat...", inline=False)
    embed.add_field(name="üí≤ Valor Total", value="Ser√° calculado automaticamente", inline=False)
    embed.set_footer(text="Voc√™ tem 1 minuto para responder")
    
    view = CarrinhoView(preco_por_1000)
    msg = await interaction.followup.send(embed=embed, view=view, wait=True)
    view.original_message = msg
    
    def check(m):
        return m.author == interaction.user and m.channel == interaction.channel
    
    try:
        msg = await bot.wait_for("message", timeout=60.0, check=check)
        quantidade = int(msg.content)
        valor_total = (quantidade / 1000) * preco_por_1000
        
        embed.set_field_at(0, name="üî¢ Quantidade", value=f"{quantidade} Robux", inline=False)
        embed.set_field_at(1, name="üí≤ Valor Total", value=f"R$ {valor_total:.2f}", inline=False)
        embed.description = f"‚úÖ Quantidade definida para **{quantidade} Robux**\n\nüíµ **Pre√ßo por 1.000 Robux:** R$ {preco_por_1000:.2f}"
        
        view.quantidade = quantidade
        await view.original_message.edit(embed=embed, view=view)
        await msg.delete()
        
    except ValueError:
        embed = Embed(
            title="‚ùå Valor Inv√°lido",
            description="Por favor, digite **apenas n√∫meros**!\nExemplo: `5000` para 5.000 Robux",
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, delete_after=10)
    except Exception as e:
        embed = Embed(
            title="‚ùå Erro Inesperado",
            description=f"Ocorreu um erro: {str(e)}",
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, delete_after=10)

# Comandos
@bot.command()
@commands.has_permissions(administrator=True)
async def set(ctx):
    embed = Embed(
        title="üåü PAINEL DE COMPRAS - FAPY STORE",
        description="Selecione abaixo como deseja comprar seus Robux:\n\n"
                   "üí∞ **Via Gamepass** (Com ou sem taxa)\n"
                   "üë• **Via Grupo** (Apenas com taxa)\n\n"
                   "üõí Clique no menu abaixo para come√ßar!",
        color=discord.Color.blue()
    )
    embed.set_image(url="https://cdn.discordapp.com/attachments/1340143464041414796/1353119422784737381/image.png")
    await ctx.send(embed=embed, view=PainelComprasView())

@bot.event
async def on_ready():
    print(f"‚úÖ Bot conectado como {bot.user}")
    try:
        await bot.tree.sync()
    except:
        pass

@bot.event
async def on_guild_channel_delete(channel):
    for user_id, carrinho in list(carrinhos_abertos.items()):
        if carrinho.id == channel.id:
            del carrinhos_abertos[user_id]
            break

bot.run(TOKEN)